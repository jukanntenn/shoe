{"version":3,"sources":["../src/util/backdrop.ts","../src/offcanvas.ts","../src/dropdown.ts","../src/scrollspy.ts"],"names":["NAME","Backdrop","constructor","config","this","elem","isAppended","show","append","hide","dispose","removeEventListener","handleClick","remove","getElement","document","body","addEventListener","bind","backdrop","createElement","className","clickCallback","defaultConfig","Offcanvas","element","isShown","Object","assign","oriTransformVal","style","transform","initializeBackDrop","toggle","_a","backdropClassName","DefaultConfig","placement","Dropdown","triggerElement","targetElement","popper","targetElem","triggerElem","handleClickOutside","ev","clickedElem","target","contains","display","Popper","createPopper","modifiers","name","options","offset","update","destroy","Scrollspy","elements","scrollElement","targets","activeTarget","tagName","window","process","refresh","offsetBase","getScrollTop","targetStack","currTarget","getTarget","selector","getSelector","trigger","find","triggerBCR","getBoundingClientRect","width","height","parent","length","top","pageYOffset","offsetTop","parse","elems","Array","isArray","Error","push","i","ele","t","pop","sort","a","b","scrollTop","getScrollHeight","scrollHeight","Math","max","documentElement","getOffsetHeight","innerHeight","activate","clear","activeClassName","tokens","split","classList","add","forEach","static","hrefAttr","getAttribute","includes","startsWith","trim","Element","prototype","querySelector","call"],"mappings":"sCAAA,MAAMA,OAAO,WAOb,MAAMC,SAOJC,YAAYC,GANJC,KAAIC,KAAuB,KAE3BD,KAAUE,YAAG,EAKnBF,KAAKD,OAASA,EAGLH,kBACT,OAAOA,OAGTO,OACEH,KAAKI,SAGPC,OACEL,KAAKM,UAGPA,UACON,KAAKE,aAGVF,KAAKC,KAAMM,oBAAoB,QAASP,KAAKQ,aAAa,GAC1DR,KAAKC,KAAMQ,SACXT,KAAKE,YAAa,GAGZE,SACN,GAAIJ,KAAKE,WACP,OAGF,MAAMD,EAAOD,KAAKU,aAClBC,SAASC,KAAKR,OAAOH,GACrBA,EAAKY,iBAAiB,QAASb,KAAKQ,YAAYM,KAAKd,OAAO,GAE5DA,KAAKE,YAAa,EAGZQ,aACN,IAAKV,KAAKC,KAAM,CACd,MAAMc,EAAWJ,SAASK,cAAc,OACpChB,KAAKD,OAAOkB,YACdF,EAASE,UAAYjB,KAAKD,OAAOkB,WAEnCjB,KAAKC,KAAOc,EAGd,OAAOf,KAAKC,KAGNO,cACFR,KAAKD,OAAOmB,eACdlB,KAAKD,OAAOmB,iBC/DlB,MAAMtB,OAAO,YAOPuB,cAAwB,CAC5BJ,UAAU,GAGZ,MAAMK,UAWJtB,YAAYuB,EAAsBtB,GAF1BC,KAAOsB,SAAG,EAGhBtB,KAAKC,KAAOoB,EACZrB,KAAKD,OAASwB,OAAOC,OAAOzB,GAAU,GAAIoB,eAC1CnB,KAAKyB,gBAAkBzB,KAAKC,KAAKyB,MAAMC,UACvC3B,KAAKe,SAAWf,KAAK4B,qBAGZhC,kBACT,OAAOA,OAGTiC,SACE,OAAO7B,KAAKsB,QAAUtB,KAAKK,OAASL,KAAKG,OAG3CA,aACEH,KAAKC,KAAKyB,MAAMC,UAAY,OAC5B3B,KAAKsB,SAAU,EACA,QAAfQ,EAAA9B,KAAKe,gBAAU,IAAAe,GAAAA,EAAA3B,OAGjBE,aACOL,KAAKsB,UAIVtB,KAAKC,KAAKyB,MAAMC,UAAY3B,KAAKyB,gBACjCzB,KAAKsB,SAAU,EACA,QAAfQ,EAAA9B,KAAKe,gBAAU,IAAAe,GAAAA,EAAAzB,QAGTuB,qBACN,GAAK5B,KAAKD,OAAOgB,SAKjB,OAAO,IAAIlB,SAAS,CAClBoB,UAAWjB,KAAKD,OAAOgC,kBACvBb,cALoB,KACpBlB,KAAKK,WCzDX,MAAMT,OAAO,WAMPoC,cAAwB,CAC5BC,UAAW,UAGb,MAAMC,SAWJpC,YACEqC,EACAC,EACArC,GATMC,KAAOsB,SAAG,EAEVtB,KAAMqC,OAAQ,KASpBrC,KAAKsC,WAAaF,EAClBpC,KAAKuC,YAAcJ,EACnBnC,KAAKD,OAAMwB,OAAAC,OAAAD,OAAAC,OAAA,GAAQQ,eAAmBjC,GAAU,IAChDC,KAAKuC,YAAY1B,iBAAiB,SAAS,KACzCb,KAAK6B,YAIEjC,kBACT,OAAOA,OAGD4C,mBAAmBC,GACzB,MAAMC,EAAcD,EAAGE,OAErBD,IAAgB1C,KAAKsC,YACpBtC,KAAKsC,WAAWM,SAASF,IACzB1C,KAAKuC,YAAYK,SAASF,KAC3B1C,KAAKsB,SAELtB,KAAKK,OAEPM,SAASC,KAAKL,oBAAoB,QAASP,KAAKwC,oBAAoB,GAGtEX,SACM7B,KAAKsB,SACPtB,KAAKK,OACLM,SAASC,KAAKL,oBAAoB,QAASP,KAAKwC,oBAAoB,IAEpExC,KAAKG,OAITA,OACEH,KAAKsC,WAAWZ,MAAMmB,QAAU,QAEhClC,SAASC,KAAKC,iBACZ,SACC4B,IACCzC,KAAKwC,mBAAmBC,MAE1B,GAGFzC,KAAKqC,OAASS,OAAOC,aAAa/C,KAAKuC,YAAavC,KAAKsC,WAAY,CACnEL,UAAWjC,KAAKD,OAAOkC,UACvBe,UAAW,CACT,CACEC,KAAM,SACNC,QAAS,CACPC,OAAQ,CAAC,EAAG,SAMpBnD,KAAKqC,OAAOe,SACZpD,KAAKsB,SAAU,EAGjBjB,OACEL,KAAKsC,WAAWZ,MAAMmB,QAAU,OAC5B7C,KAAKqC,QACPrC,KAAKqC,OAAOgB,UAEdrD,KAAKsB,SAAU,GC9FnB,MAAM1B,KAAO,YAYb,MAAM0D,UASJxD,YACEyD,EACAC,EAA6B7C,SAASC,KACtCb,EAAiB,IAXXC,KAAOyD,QAAa,GAIpBzD,KAAY0D,aAAkB,KAE9B1D,KAAMD,OAAW,GAOvBC,KAAKwD,cACuB,SAA1BA,EAAcG,QAAqBC,OAASJ,EAC9CxD,KAAKwD,cAAc3C,iBAAiB,UAAU,KAC5Cb,KAAK6D,aAEPtC,OAAOC,OAAOxB,KAAKD,OAAQA,GAE3BC,KAAK8D,QAAQP,GACbvD,KAAK6D,UAGIjE,kBACT,OAAOA,KAGTkE,QAAQP,GACN,MAAMQ,EAAa/D,KAAKwD,gBAAkBI,OAAS,EAAI5D,KAAKgE,eACtDC,EAAiC,GACvC,IAAIC,EAEJ,MAAMC,EAAalE,IACjB,MAAMmE,EAAWd,UAAUe,YAAYpE,GACjCqE,EAAUF,EACZd,UAAUiB,KACRH,EACCpE,KAAKwD,gBAAkBI,OACpBjD,SAASC,KACTZ,KAAKwD,eAEX,KACJ,IAAKc,EAAS,OAAO,KACrB,MAAME,EAAaF,EAAQG,wBAC3B,OAAOD,EAAWE,OAASF,EAAWG,OAClC,CACEC,OAAQX,EAAYA,EAAYY,OAAS,GACzCxD,QAASpB,EACTkD,OACEnD,KAAKwD,gBAAkBI,OACnBY,EAAWM,IAAMlB,OAAOmB,YAAchB,EACrCO,EAAwBU,UAAYjB,GAE7C,MAGAkB,EAASC,IACb,GAAqB,IAAjBA,EAAML,QAAgBM,MAAMC,QAAQ7B,EAAS,IAC/C,MAAM,IAAI8B,MAAM,0BAGlB,MAAM1C,EAASwB,EAAUe,EAAM,IAChB,OAAXvC,GACF3C,KAAKyD,QAAQ6B,KAAK3C,GAEpBuB,EAAavB,EACb,IAAK,IAAI4C,EAAI,EAAGA,EAAIL,EAAML,OAAQU,GAAK,EAAG,CACxC,MAAMC,EAAMN,EAAMK,GAClB,GAAIJ,MAAMC,QAAQI,GAChBvB,EAAYqB,KAAKpB,GACjBe,EAAMO,OACD,CACL,MAAMC,EAAItB,EAAUqB,GACV,OAANC,GACFzF,KAAKyD,QAAQ6B,KAAKG,GAEpBvB,EAAauB,GAGjBxB,EAAYyB,OAGdT,EAAM1B,GACNvD,KAAKyD,QAAUzD,KAAKyD,QAAQkC,MAAK,CAACC,EAAGC,IAAMD,EAAEzC,OAAS0C,EAAE1C,SAGlDa,eACN,OAAOhE,KAAKwD,gBAAkBI,OAC1B5D,KAAKwD,cAAcuB,YAClB/E,KAAKwD,cAA8BsC,UAGlCC,kBACN,OACG/F,KAAKwD,cAA8BwC,cACpCC,KAAKC,IACHvF,SAASC,KAAKoF,aACdrF,SAASwF,gBAAgBH,cAKvBI,kBACN,OAAOpG,KAAKwD,gBAAkBI,OAC1BA,OAAOyC,YACNrG,KAAKwD,cAA8BiB,wBAAwBE,OAG1Dd,UACN,MAAMiC,EAAY9F,KAAKgE,eAIvB,GAAI8B,GAHiB9F,KAAK+F,kBACO/F,KAAKoG,kBAEtC,CACE,MAAMzD,EAAS3C,KAAKyD,QAAQzD,KAAKyD,QAAQoB,OAAS,GAE9C7E,KAAK0D,eAAiBf,GACxB3C,KAAKsG,SAAS3D,OAJlB,CASA,GACE3C,KAAK0D,cACLoC,EAAY9F,KAAKyD,QAAQ,GAAGN,QAC5BnD,KAAKyD,QAAQ,GAAGN,OAAS,EAIzB,OAFAnD,KAAK0D,aAAe,UACpB1D,KAAKuG,QAIP,IAAK,IAAIhB,EAAI,EAAGA,EAAIvF,KAAKyD,QAAQoB,OAAQU,GAAK,EAE1CvF,KAAK0D,eAAiB1D,KAAKyD,QAAQ8B,IACnCO,GAAa9F,KAAKyD,QAAQ8B,GAAGpC,cACG,IAAxBnD,KAAKyD,QAAQ8B,EAAI,IACvBO,EAAY9F,KAAKyD,QAAQ8B,EAAI,GAAGpC,SAGlCnD,KAAKsG,SAAStG,KAAKyD,QAAQ8B,KAKzBe,SAAS3D,GAIf,GAHA3C,KAAK0D,aAAef,EACpB3C,KAAKuG,QAEDvG,KAAKD,OAAOyG,gBAAiB,CAC/B,MAAMC,EAASzG,KAAKD,OAAOyG,gBAAgBE,MAAM,KACjD1G,KAAK0D,aAAarC,QAAQsF,UAAUC,OAAOH,GAC3C,IAAI7B,OAAEA,GAAWjC,EACjB,KAAOiC,GACLA,EAAOvD,QAAQsF,UAAUC,OAAOH,GAChC7B,EAASA,EAAOA,QAKd2B,QACN,GAAIvG,KAAKD,OAAOyG,gBAAiB,CAC/B,MAAMC,EAASzG,KAAKD,OAAOyG,gBAAgBE,MAAM,KACjD1G,KAAKyD,QAAQoD,SAASlE,GACpBA,EAAOtB,QAAQsF,UAAUlG,UAAUgG,MAKjCK,mBAAmBtB,GACzB,IAAIpB,EAAW,KACX2C,EAAWvB,EAAIwB,aAAa,QAChC,OAAKD,IAAcA,EAASE,SAAS,MAASF,EAASG,WAAW,OAI9DH,EAASE,SAAS,OAASF,EAASG,WAAW,OACjDH,EAAW,IAAIA,EAASL,MAAM,KAAK,MAGrCtC,EAAW2C,GAAyB,MAAbA,EAAmBA,EAASI,OAAS,KACrD/C,GARE,KAWH0C,YAAY1C,EAAkB/C,EAAuBV,SAASC,MACpE,OAAOwG,QAAQC,UAAUC,cAAcC,KAAKlG,EAAS+C","sourcesContent":["const NAME = \"backdrop\";\n\ntype Config = {\n  className?: string;\n  clickCallback: null | undefined | (() => void);\n};\n\nclass Backdrop {\n  private elem: null | HTMLElement = null;\n\n  private isAppended = false;\n\n  private config;\n\n  constructor(config: Config) {\n    this.config = config;\n  }\n\n  static get NAME() {\n    return NAME;\n  }\n\n  show() {\n    this.append();\n  }\n\n  hide() {\n    this.dispose();\n  }\n\n  dispose() {\n    if (!this.isAppended) {\n      return;\n    }\n    this.elem!.removeEventListener(\"click\", this.handleClick, true);\n    this.elem!.remove();\n    this.isAppended = false;\n  }\n\n  private append() {\n    if (this.isAppended) {\n      return;\n    }\n\n    const elem = this.getElement();\n    document.body.append(elem);\n    elem.addEventListener(\"click\", this.handleClick.bind(this), true);\n\n    this.isAppended = true;\n  }\n\n  private getElement() {\n    if (!this.elem) {\n      const backdrop = document.createElement(\"div\");\n      if (this.config.className) {\n        backdrop.className = this.config.className;\n      }\n      this.elem = backdrop;\n    }\n\n    return this.elem;\n  }\n\n  private handleClick() {\n    if (this.config.clickCallback) {\n      this.config.clickCallback();\n    }\n  }\n}\n\nexport default Backdrop;\n","import Backdrop from \"./util/backdrop\";\n\nconst NAME = \"offcanvas\";\n\ntype Config = {\n  backdrop: boolean;\n  backdropClassName?: string;\n};\n\nconst defaultConfig: Config = {\n  backdrop: true,\n};\n\nclass Offcanvas {\n  private readonly elem;\n\n  private config;\n\n  private backdrop?: Backdrop;\n\n  private readonly oriTransformVal;\n\n  private isShown = false;\n\n  constructor(element: HTMLElement, config?: Config) {\n    this.elem = element;\n    this.config = Object.assign(config || {}, defaultConfig);\n    this.oriTransformVal = this.elem.style.transform;\n    this.backdrop = this.initializeBackDrop();\n  }\n\n  static get NAME() {\n    return NAME;\n  }\n\n  toggle() {\n    return this.isShown ? this.hide() : this.show();\n  }\n\n  show() {\n    this.elem.style.transform = \"none\";\n    this.isShown = true;\n    this.backdrop?.show();\n  }\n\n  hide() {\n    if (!this.isShown) {\n      return;\n    }\n\n    this.elem.style.transform = this.oriTransformVal;\n    this.isShown = false;\n    this.backdrop?.hide();\n  }\n\n  private initializeBackDrop(): undefined | Backdrop {\n    if (!this.config.backdrop) return undefined;\n\n    const clickCallback = () => {\n      this.hide();\n    };\n    return new Backdrop({\n      className: this.config.backdropClassName,\n      clickCallback,\n    });\n  }\n}\n\nexport default Offcanvas;\n","import * as Popper from \"@popperjs/core\";\n\nconst NAME = \"dropdown\";\n\ntype Config = {\n  placement: \"top\" | \"right\" | \"bottom\" | \"left\";\n};\n\nconst DefaultConfig: Config = {\n  placement: \"bottom\",\n};\n\nclass Dropdown {\n  private targetElem: HTMLElement;\n\n  private triggerElem: HTMLElement;\n\n  private isShown = false;\n\n  private popper: any = null;\n\n  private config: Config;\n\n  constructor(\n    triggerElement: HTMLElement,\n    targetElement: HTMLElement,\n    config?: Config\n  ) {\n    this.targetElem = targetElement;\n    this.triggerElem = triggerElement;\n    this.config = { ...DefaultConfig, ...(config || {}) };\n    this.triggerElem.addEventListener(\"click\", () => {\n      this.toggle();\n    });\n  }\n\n  static get NAME() {\n    return NAME;\n  }\n\n  private handleClickOutside(ev: MouseEvent): any {\n    const clickedElem = ev.target as Node;\n    if (\n      clickedElem !== this.targetElem &&\n      !this.targetElem.contains(clickedElem) &&\n      !this.triggerElem.contains(clickedElem) &&\n      this.isShown\n    ) {\n      this.hide();\n    }\n    document.body.removeEventListener(\"click\", this.handleClickOutside, true);\n  }\n\n  toggle() {\n    if (this.isShown) {\n      this.hide();\n      document.body.removeEventListener(\"click\", this.handleClickOutside, true);\n    } else {\n      this.show();\n    }\n  }\n\n  show() {\n    this.targetElem.style.display = \"block\";\n\n    document.body.addEventListener(\n      \"click\",\n      (ev) => {\n        this.handleClickOutside(ev);\n      },\n      true\n    );\n\n    this.popper = Popper.createPopper(this.triggerElem, this.targetElem, {\n      placement: this.config.placement,\n      modifiers: [\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 10],\n          },\n        },\n      ],\n    });\n\n    this.popper.update();\n    this.isShown = true;\n  }\n\n  hide() {\n    this.targetElem.style.display = \"none\";\n    if (this.popper) {\n      this.popper.destroy();\n    }\n    this.isShown = false;\n  }\n}\n\nexport default Dropdown;\n","const NAME = \"scrollspy\";\n\ntype Target = {\n  parent: Target | null;\n  element: HTMLElement;\n  offset: number;\n};\n\ntype Config = {\n  activeClassName?: string;\n};\n\nclass Scrollspy {\n  private targets: Target[] = [];\n\n  private scrollElement;\n\n  private activeTarget: null | Target = null;\n\n  private config: Config = {};\n\n  constructor(\n    elements: HTMLElement[],\n    scrollElement: HTMLElement = document.body,\n    config: Config = {}\n  ) {\n    this.scrollElement =\n      scrollElement.tagName === \"BODY\" ? window : scrollElement;\n    this.scrollElement.addEventListener(\"scroll\", () => {\n      this.process();\n    });\n    Object.assign(this.config, config);\n\n    this.refresh(elements);\n    this.process();\n  }\n\n  static get NAME() {\n    return NAME;\n  }\n\n  refresh(elements: HTMLElement[]) {\n    const offsetBase = this.scrollElement === window ? 0 : this.getScrollTop();\n    const targetStack: (Target | null)[] = [];\n    let currTarget: Target | null;\n\n    const getTarget = (elem: HTMLElement): Target | null => {\n      const selector = Scrollspy.getSelector(elem);\n      const trigger = selector\n        ? Scrollspy.find(\n            selector,\n            (this.scrollElement === window\n              ? document.body\n              : this.scrollElement) as HTMLElement\n          )\n        : null;\n      if (!trigger) return null;\n      const triggerBCR = trigger.getBoundingClientRect();\n      return triggerBCR.width || triggerBCR.height\n        ? {\n            parent: targetStack[targetStack.length - 1],\n            element: elem,\n            offset:\n              this.scrollElement === window\n                ? triggerBCR.top + window.pageYOffset + offsetBase\n                : (trigger as HTMLElement).offsetTop + offsetBase,\n          }\n        : null;\n    };\n\n    const parse = (elems: HTMLElement[]) => {\n      if (elems.length === 0 || Array.isArray(elements[0])) {\n        throw new Error(\"Invalid tree structure\");\n      }\n\n      const target = getTarget(elems[0]);\n      if (target !== null) {\n        this.targets.push(target);\n      }\n      currTarget = target;\n      for (let i = 1; i < elems.length; i += 1) {\n        const ele = elems[i];\n        if (Array.isArray(ele)) {\n          targetStack.push(currTarget);\n          parse(ele);\n        } else {\n          const t = getTarget(ele);\n          if (t !== null) {\n            this.targets.push(t);\n          }\n          currTarget = t;\n        }\n      }\n      targetStack.pop();\n    };\n\n    parse(elements);\n    this.targets = this.targets.sort((a, b) => a.offset - b.offset);\n  }\n\n  private getScrollTop() {\n    return this.scrollElement === window\n      ? this.scrollElement.pageYOffset\n      : (this.scrollElement as HTMLElement).scrollTop;\n  }\n\n  private getScrollHeight() {\n    return (\n      (this.scrollElement as HTMLElement).scrollHeight ||\n      Math.max(\n        document.body.scrollHeight,\n        document.documentElement.scrollHeight\n      )\n    );\n  }\n\n  private getOffsetHeight() {\n    return this.scrollElement === window\n      ? window.innerHeight\n      : (this.scrollElement as HTMLElement).getBoundingClientRect().height;\n  }\n\n  private process() {\n    const scrollTop = this.getScrollTop();\n    const scrollHeight = this.getScrollHeight();\n    const maxScroll = scrollHeight - this.getOffsetHeight();\n\n    if (scrollTop >= maxScroll) {\n      const target = this.targets[this.targets.length - 1];\n\n      if (this.activeTarget !== target) {\n        this.activate(target);\n      }\n      return;\n    }\n\n    if (\n      this.activeTarget &&\n      scrollTop < this.targets[0].offset &&\n      this.targets[0].offset > 0\n    ) {\n      this.activeTarget = null;\n      this.clear();\n      return;\n    }\n\n    for (let i = 0; i < this.targets.length; i += 1) {\n      const isActiveTarget =\n        this.activeTarget !== this.targets[i] &&\n        scrollTop >= this.targets[i].offset &&\n        (typeof this.targets[i + 1] === \"undefined\" ||\n          scrollTop < this.targets[i + 1].offset);\n\n      if (isActiveTarget) {\n        this.activate(this.targets[i]);\n      }\n    }\n  }\n\n  private activate(target: Target) {\n    this.activeTarget = target;\n    this.clear();\n\n    if (this.config.activeClassName) {\n      const tokens = this.config.activeClassName.split(\" \");\n      this.activeTarget.element.classList.add(...tokens);\n      let { parent } = target;\n      while (parent) {\n        parent.element.classList.add(...tokens);\n        parent = parent.parent;\n      }\n    }\n  }\n\n  private clear() {\n    if (this.config.activeClassName) {\n      const tokens = this.config.activeClassName.split(\" \");\n      this.targets.forEach((target) =>\n        target.element.classList.remove(...tokens)\n      );\n    }\n  }\n\n  private static getSelector(ele: HTMLElement): null | string {\n    let selector = null;\n    let hrefAttr = ele.getAttribute(\"href\");\n    if (!hrefAttr || (!hrefAttr.includes(\"#\") && !hrefAttr.startsWith(\".\"))) {\n      return null;\n    }\n\n    if (hrefAttr.includes(\"#\") && !hrefAttr.startsWith(\"#\")) {\n      hrefAttr = `#${hrefAttr.split(\"#\")[1]}`;\n    }\n\n    selector = hrefAttr && hrefAttr !== \"#\" ? hrefAttr.trim() : null;\n    return selector;\n  }\n\n  private static find(selector: string, element: HTMLElement = document.body) {\n    return Element.prototype.querySelector.call(element, selector);\n  }\n}\n\nexport default Scrollspy;\n"]}